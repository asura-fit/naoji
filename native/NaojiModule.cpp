/**
 * @author sey
 *
 * Version : $Id$
 * This file was generated by Aldebaran Robotics ModuleGenerator
 */

#include <iostream>
#include "alproxy.h"
#include "alptr.h"
#include "albroker.h"

#include <jni.h>       /* where everything is defined */
#include "NaojiModule.hpp"

using namespace AL;
using namespace Naoji;

//______________________________________________
// constructor
//______________________________________________
NaojiModule::NaojiModule(ALPtr<ALBroker> pBroker, const std::string& pName) :
	ALModule(pBroker, pName) {
	setModuleDescription(
			"This an autogenerated module, this description need to be updated.");

	functionName("DummyFunction", "NaojiModule",
			"A autogenerated dummyFunction.");
	addParam(
			"msg",
			"A string describing a message: the module will say this message when this method is called");
	addParam("foo", "Another parameter example");
	setReturn("return", "Returns the foo param");
	BIND_METHOD(NaojiModule::dummyFunction);

	isOk = true;
}

//______________________________________________
// destructor
//______________________________________________
NaojiModule::~NaojiModule() {

}

//______________________________________________
// version
//______________________________________________
std::string NaojiModule::version() {
	return ALTools_GetVersionString(NaojiModule_VERSION_MAJOR, NaojiModule_VERSION_MINOR, "0", "0");
}

/**
 * dataChanged. Called by ALMemory when subcription
 * has been modified.
 * @param pDataName, name of the suscribed data
 * @param pValue, value of the suscribed data
 * @param pMessage, message written by user during suscription
 */
void NaojiModule::dataChanged(const std::string& pDataName,
		const ALValue& pValue, const std::string& pMessage) {

}

/**
 * innerTest
 */
bool NaojiModule::innerTest() {
	bool result = true;
	// put here code dedicaced to autotest this module.
	// return false if fail, success otherwise
	result = isOk;
	return result;
}

/**
 * dummy Function
 * @param pMsg Message to show on screen
 * @param pNawak the function will return this parameter
 * @return an alvalue
 */
ALValue NaojiModule::dummyFunction(const std::string& pMsg, const ALValue& pFoo) {
	std::cout << "NaojiModule say : " << pMsg << std::endl;
	if (pFoo.isValid())
		std::cout << "Return value: " << pFoo.toString(VerbosityMini)
				<< std::endl;
	else
		std::cout << "The value you send me is invalid" << std::endl;

	return pFoo;
}

void NaojiModule::initNaojiModule() {
	JNIEnv *env; /* pointer to native method interface */

	JavaVMInitArgs vm_args;
	JavaVMOption options[4];

	int res;

	vm_args.version = JNI_VERSION_1_6;
	vm_args.options = options;
	vm_args.nOptions = 2;
	vm_args.ignoreUnrecognized = false;

	options[0].optionString = "-Djava.class.path=."; /* user classes */
	options[1].optionString = "-Djava.library.path=."; /* set native library path */
	options[2].optionString = "-verbose:jni"; /* print JNI-related messages */
	options[3].optionString = "-Djava.compiler=NONE"; /* disable JIT */

	/* Note that in the JDK, there is no longer any need to call
	 * JNI_GetDefaultJavaVMInitArgs.
	 */
	res = JNI_CreateJavaVM(&jvm, (void**) &env, &vm_args);

	if (res < 0) {
		printf("error %d\n", res);
		isOk = false;
		return;
	}
	/* invoke the Main.test method using the JNI */
	jclass cls = env->FindClass("jp/ac/fit/asura/naoji/Naoji");
	if (cls == NULL) {
		printf("cls is null\n");
		isOk = false;
		return;
	}

	jmethodID mid = env->GetStaticMethodID(cls, "test", "()V");
	if (mid == NULL) {
		printf("mid is null\n");
		isOk = false;
		return;
	}
	env->CallStaticVoidMethod(cls, mid);
}

void NaojiModule::exitNaojiModule() {
	/* We are done. */
	jvm->DestroyJavaVM();
}
